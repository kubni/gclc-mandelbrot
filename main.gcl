background 200 0 0
dim 150 100
area -2 -1.5 0.5 1.5

number density 50
number xmin -2 
number xmax 0.5 
number ymin -1.5
number ymax 1.5

% Kreiramo tacaka cije su x i y koordinate jednako rasporedjene u opsegu [xmin, ..., xmax] i [ymin, ..., ymax]
% Broj tacaka je odredjen sa density
array C { density density }
number i 1
while { i <= density }
{
  expression x_step {(xmax - xmin) / (density - 1)}
  expression re_coord { xmin + x_step * (i-1) }
  number j 1
  while { j <= density }
  {
    
    expression y_step {(ymax - ymin) / (density - 1)}
    expression im_coord { ymin + y_step * (j-1) }
    point P re_coord im_coord
    set_equal C[i][j] P
    expression j { j + 1 }
  }
  expression i { i + 1 }
}

% Kreiramo masku, matricu koja odredjuje koja tacka iz C ce biti iscrtana kasnije.
% Postoji tacka acc_point koja se koristi za dobijanje elemenata niza po formuli:
% z_0 = 0
% z_n = z^2_{n-1} + c
% Racunamo samo dok je abs(z) <= 2 jer je to zadat uslov.
array mask_array { density density }
number max_iterations 20
number k 1
while { k <= density }
{
  number f 1
  while { f <= density }
  {
    number l 1 
    point acc_point 0 0
    while { l <= max_iterations }
    {
       getx a_re acc_point
       gety a_im acc_point
       getx b_re acc_point
       gety b_im acc_point
       expression re_part { a_re * b_re - a_im * b_im }
       expression im_part { a_re * b_im + a_im * b_re }
       point tmp_point re_part im_part
       set_equal acc_point tmp_point

       getx a_re acc_point
       gety a_im acc_point 
       getx b_re C[k][f]
       gety b_im C[k][f]
       expression re_part { a_re + b_re }
       expression im_part { a_im + b_im }
       point tmp_point re_part im_part
       set_equal acc_point tmp_point

       getx re acc_point
       gety im acc_point
       expression tmp_abs {sqrt(re*re+im*im)} 

       % Ukoliko predjemo 2, prekidamo petlju ranije
       if_then_else { tmp_abs > 2 }
       {
         expression mask_array[k][f] {-1} 
         expression l { max_iterations + 1 }
       }
       {
       }
       expression l { l + 1 }
    }
    expression f { f + 1 }
  }
  expression k { k + 1 }
}


% Crtanje tacaka, crtamo samo one koje su ostale 0 u mask_array
number i 1
while { i <= density }
{
  number j 1
  while { j <= density }
  {
    if_then_else { mask_array[i][j] == 0 }
    {
      drawpoint C[i][j] 
    }
    {
    }
    expression j { j + 1 }
  }

  expression i { i + 1 }
}
